#!/usr/bin/env ruby

require_relative '../lib'

Button = Data.define(:label, :position)

class Keypad
  def initialize(button_labels)
    @buttons = button_labels.each_with_index.flat_map do |y_labels, y|
      y_labels.each_with_index.filter_map do |label, x|
        next if label.nil?

        Button.new(label:, position: Vector.new(x, y))
      end
    end
  end

  def remote_keys(label_from, label_to)
    return [[]] if label_from == label_to

    from = button_position(label_from)
    to = button_position(label_to)
    distance = to - from
    return [keys(distance)] if distance.x.zero? || distance.y.zero?

    x_distance = Vector.new(distance.x, 0)
    y_distance = Vector.new(0, distance.y)

    results = []
    results << (keys(x_distance) + keys(y_distance)) if valid_path?(from, from + x_distance, to)
    results << (keys(y_distance) + keys(x_distance)) if valid_path?(from, from + y_distance, to)
    raise 'should not happen' if results.empty?

    results
  end

  def distance(label_from, label_to)
    from = button_position(label_from)
    to = button_position(label_to)

    distance = to - from
    distance.x + distance.y
  end

  def inspect = "Keypad(#{buttons_by_label.keys.join(', ')})"

  private

  attr_reader :buttons

  def button_position(label) = buttons_by_label.fetch(label).position

  def keys(distance)
    x_char = distance.x.negative? ? '<' : '>'
    y_char = distance.y.negative? ? '^' : 'v'
    ([x_char] * distance.x.abs) + ([y_char] * distance.y.abs)
  end

  def valid_path?(from, via, to)
    positions =
      Path.new([from, via]).fill_gaps.positions[1..] +
      Path.new([via, to]).fill_gaps.positions[1..]
    positions.all? { button_at?(_1) }
  end

  def index_by(array, &) = array.each_with_object({}) { |e, memo| memo[yield(e)] = e }
  def buttons_by_label = @buttons_by_label ||= index_by(buttons, &:label)
  def buttons_by_position = @buttons_by_position ||= index_by(buttons, &:position)
  def button_at?(position) = buttons_by_position.key?(position)
end

class KeySequence
  def initialize(keypad)
    @last_button = 'A'
    @keypad = keypad
  end

  def remote_keys(button)
    options = keypad.remote_keys(last_button, button)
    self.last_button = button
    options.map { [*_1, 'A'] }
  end

  def distance_to_last_button(button) = keypad.distance(last_button, button)
  def state = [keypad.object_id, last_button]

  def dup
    result = self.class.new(keypad)
    result.last_button = last_button
    result
  end

  protected

  attr_writer :last_button

  private

  attr_reader :keypad, :last_button
end

class RequiredPresses
  def initialize
    @cache = {}
    @log_state = []
  end

  def press_count(door_buttons)
    door_remote, *robot_remotes = make_remotes
    remote_buttons = door_buttons.flat_map { press_one(door_remote, robot_remotes.first, _1) }
    remote_buttons.each_with_index.sum do |button, i|
      puts "#{i}/#{remote_buttons.length}"
      robot_remotes, buttons = press_cascade_memoized(robot_remotes, button)
      # pp(result: { door_button: button, remote_buttons: buttons })
      buttons.count
    end
  end

  private

  attr_reader :last_char, :cache

  DOOR_KEYPAD = Keypad.new([%w[7 8 9], %w[4 5 6], %w[1 2 3], [nil, '0', 'A']])
  REMOTE_KEYPAD = Keypad.new([[nil, '^', 'A'], %w[< v >]])
  CACHE_LENGTH = 10
  INTERMEDIATE_REMOTE_COUNT = 25

  private_constant :DOOR_KEYPAD, :REMOTE_KEYPAD, :CACHE_LENGTH, :INTERMEDIATE_REMOTE_COUNT

  def make_remotes
    my_remote = KeySequence.new(REMOTE_KEYPAD)
    intermediate_remotes = INTERMEDIATE_REMOTE_COUNT.times.map { KeySequence.new(REMOTE_KEYPAD) }
    door_remote = KeySequence.new(DOOR_KEYPAD)
    [door_remote, *intermediate_remotes, my_remote]
  end

  def press_cascade_memoized(key_sequences, button, last_downstream: nil)
    # pp(press_cascade_memoized: {
    #      key_sequences_w_ld: [*key_sequences, last_downstream].compact,
    #      button:,
    #      last_downstream_nil: last_downstream.nil?
    #    })

    if ENV['UNCACHED'] != '1' && key_sequences.length > CACHE_LENGTH
      @log_state[0] = { ks_length: key_sequences.length, result: :delegate }
      cached = key_sequences[...CACHE_LENGTH]
      left = key_sequences[CACHE_LENGTH...]
      raise 'boom' if cached + left != key_sequences

      cached, downstream_buttons =
        press_cascade_memoized(cached, button, last_downstream: left.first)
      result_buttons = downstream_buttons.flat_map do |downstream_button|
        left, downstream_buttons = press_cascade_memoized(left, downstream_button)
        downstream_buttons
      end
      return log_result([[*cached, *left], result_buttons])
    end

    key = [key_sequences.map(&:state), last_downstream&.state, button]
    cached = fetch_cache(key)

    @log_state[0] = { ksl: key_sequences.length, miss: cached.nil?, cs: cache.size }
    # pp(t: :cache_hit) unless cached.nil?
    return log_result(cached) unless cached.nil?

    result_key_sequences, result_buttons = press_cascade(key_sequences, button, last_downstream:)
    result = [result_key_sequences.map(&:dup), result_buttons]

    @cache[key] = result
    log_result(fetch_cache(key))
  end

  def update_log = print("\r" + @log_state.map(&:inspect).join(' / ') + (' ' * 20))

  def log_result(result)
    key_sequences, buttons = result
    @log_state[1] = { ksl: key_sequences.length, bl: buttons.length }
    @log_state[2] ||= { max_ksl: key_sequences.length, max_bl: buttons.length }
    @log_state[2][:max_ksl] = [@log_state[2][:max_ksl], key_sequences.length].max
    @log_state[2][:max_bl] = [@log_state[2][:max_bl], buttons.length].max
    update_log
    result
  end

  def fetch_cache(key)
    key_sequences, buttons = cache[key]
    return nil if key_sequences.nil?

    [key_sequences.map(&:dup), buttons]
  end

  def press_cascade(key_sequences, button, last_downstream: nil)
    # pp(press_cascade: { key_sequences_w_ld: [*key_sequences, last_downstream].compact, button:,
    #                     last_downstream_nil: last_downstream.nil? })
    first, downstream, *rest = key_sequences
    buttons = press_one(first, downstream || last_downstream, button)

    return [key_sequences, buttons] if key_sequences.length == 1

    downstream_key_sequences = [downstream, *rest]
    result = buttons.flat_map do |remote_button|
      downstream_key_sequences, downstream_buttons =
        press_cascade_memoized(downstream_key_sequences, remote_button, last_downstream:)
      downstream_buttons
    end
    [[first, *downstream_key_sequences], result]
  end

  def press_one(sequence, downstream, button)
    # pp(press_one: { sequence:, downstream:, button: })
    options = sequence.remote_keys(button)
    return options.first if downstream.nil?

    options.min_by { |option_buttons| downstream.distance_to_last_button(option_buttons.first) }
  end
end

def code_presses(code)
  RequiredPresses.new.press_count(code.chars)
end

def numeric_part(code) = code.scan(/[0-9]/).join.to_i
def complexity(code) = numeric_part(code) * code_presses(code)

codes = ARGF.readlines(chomp: true)
# pp codes.map { [_1, code_presses(_1), numeric_part(_1)] }
pp codes.sum {
  pp(code: _1)
  complexity(_1)
}
